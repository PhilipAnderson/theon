use typenum::Unsigned;

use crate::partition::{Partition, Subdivide};
use crate::query::{Aabb, Intersection};
use crate::space::{EuclideanSpace, FiniteDimensional, Scalar, Vector};
use crate::{Converged, FromItems, Half, IntoItems, IteratorExt};

// TODO: The composite API is not powerful enough to implement these traits
//       without de/composing types into iterators. Perhaps that API could
//       support mapping `Item` into different types  and an explicit mechanism
//       to index dimensions.

pub struct NCube<S>
where
    S: EuclideanSpace,
{
    origin: S,
    width: Scalar<S>,
}

impl<S> NCube<S>
where
    S: EuclideanSpace,
{
    fn center(&self) -> S
    where
        Vector<S>: Converged,
    {
        self.origin + Vector::<S>::converged(self.width.half())
    }

    fn aabb(&self) -> Aabb<S>
    where
        Vector<S>: Converged,
    {
        Aabb {
            origin: self.origin,
            extent: Converged::converged(self.width),
        }
    }
}

impl<S> Partition<S> for NCube<S>
where
    S: EuclideanSpace + FiniteDimensional + FromItems + IntoItems,
    Vector<S>: Converged,
{
    fn contains(&self, point: &S) -> bool {
        self.aabb().intersection(point).is_some()
    }

    fn index(&self, point: &S) -> usize {
        point
            .into_items()
            .into_iter()
            .zip(self.center().into_items())
            .enumerate()
            .map(|(dimension, (x, c))| {
                if x < c {
                    0
                }
                else {
                    1 << dimension
                }
            })
            .sum()
    }
}

impl<S> Subdivide for NCube<S>
where
    S: EuclideanSpace + FiniteDimensional + FromItems + IntoItems,
{
    // TODO: Is it possible to constrain `FiniteDimensional` and specify an
    //       `ArrayVec` of the correct capacity? Maybe the implementation of
    //       `subdivide` could be factored out in a generic way and its output
    //       iterator could be collected within `impl` blocks generated by a
    //       macro.
    type Output = Vec<Self>;

    fn subdivide(&self) -> Self::Output {
        let width = self.width.half();
        let n = 2i32.pow(<S as FiniteDimensional>::N::U32);
        (0i32..n)
            .map(|index| {
                let origin = self
                    .origin
                    .into_items()
                    .into_iter()
                    .enumerate()
                    .map(
                        |(dimension, x)| match (index / (2i32.pow(dimension as u32))) % 2i32 {
                            0 => x,
                            1 => x + width,
                            _ => unreachable!(),
                        },
                    )
                    .compose::<S>()
                    .unwrap();
                NCube { origin, width }
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use nalgebra::{Point2, Point3};

    use crate::partition::{NCube, Partition, Subdivide};
    use crate::space::EuclideanSpace;

    type E2 = Point2<f64>;
    type E3 = Point3<f64>;

    #[test]
    fn partition_e2() {
        let cube = NCube::<E2> {
            origin: EuclideanSpace::origin(),
            width: 8.0,
        };
        assert_eq!(0, cube.index(&EuclideanSpace::origin()));
        assert_eq!(3, cube.index(&EuclideanSpace::from_xy(4.0, 4.0)));
        assert!(cube.contains(&EuclideanSpace::origin()));
        assert!(cube.contains(&EuclideanSpace::from_xy(4.0, 4.0)));
    }

    #[test]
    fn subdivide_e2() {
        let cube = NCube::<E2> {
            origin: EuclideanSpace::origin(),
            width: 8.0,
        };
        let divisions = cube.subdivide();
        assert_eq!(4, divisions.len());
        assert!(divisions.iter().all(|cube| cube.width == 4.0));
    }

    #[test]
    fn subdivide_e3() {
        let cube = NCube::<E3> {
            origin: EuclideanSpace::origin(),
            width: 8.0,
        };
        let divisions = cube.subdivide();
        assert_eq!(8, divisions.len());
        assert!(divisions.iter().all(|cube| cube.width == 4.0));
    }
}
